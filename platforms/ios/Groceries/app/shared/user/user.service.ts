import { Injectable } from "@angular/core";
import { Http, Headers, Response } from "@angular/http";
import { Observable } from "rxjs/Rx";
import "rxjs/add/operator/do";
import "rxjs/add/operator/map";

import { User } from "./user";
import { Config } from "../config";

/**
 * Injectable just means to use dependency injection which is a fancy way of removing need for understanding subclasses to define a class.
 * This service is going to call some API and send it the user email and password for storage somewhere at telrik.
 */
@Injectable()
export class UserService {
  /**
   * Add a an instance of default Http object.
  */
  constructor(private http: Http) {}

  /**
   * Basically call some API to store a new user.
   * @param user is created from the login email and password fields, DI removes need to know this.
   */
  register(user: User) {
    /**
     * Apparently Telrik API's don't require any token?
     */
    let headers = new Headers();
    headers.append("Content-Type", "application/json");

    return this.http.post(
      Config.apiUrl + "Users",
      JSON.stringify({
        Username: user.email,
        Email: user.email,
        Password: user.password
      }),
      { headers: headers }
    )
    .catch(this.handleErrors);

    // alert("About to register: " + user.email + " with password " + user.password + ".");
  }

  login(user: User) {
    let headers = new Headers();
    headers.append("Content-Type", "application/json");

    return this.http.post(
      Config.apiUrl + "oauth/token",
      JSON.stringify({
        username: user.email,
        password: user.password,
        grant_type: "password"
      }),
      { headers: headers }
    )
    .map(response => response.json())
    .do(data => {
      Config.token = data.Result.access_token;
    })
    .catch(this.handleErrors);
  }

  /**
   * This will print any errors generated by our post to the telrik API.
   * @param error is the error generated by the http post to telrik.
   */
  handleErrors(error: Response) {
    console.log(JSON.stringify(error.json()));
    return Observable.throw(error);
  }
}